#计时器

* 它是一种输入设备，每隔一段时间都会周期性的通知应用程序
* `SetTimer(hwnd, nIDEvent, uElapse, LpTimerFunc)`创建一个计时器
	* `hwnd`如果是NULL，则不会起任何作用
	* `nIDEvent`计时器的识别码，如果一个识别码对应多个计时器，系统会保留最新的那个，丢掉其他的，并且重置新的计时器
	* `uElapse`设定计时器时间， 时间在0x0A~0x7FFFFFFF,最小值叫`USER_TIMER_MINIMUM`，最大值叫`USER_TIMER_MAXIMUM`
	* 最后一个参数是函数指针，表示计时器唤醒时通知哪个函数，如果是NULL，则向窗口过程发送`WM_TIMER`消息
	* 相应的还有`KillTimer(hwnd, nIDEvent)`销毁注册好的计时器

**`WM_TIMER`的处理逻辑，及自我修养**

* `WM_TIMER`
	* `wParam`表示计时器的ID
	* `lParam`表示计时器发送中断时接收中断的函数的函数指针
* 异步：提交请求后继续干别的事等待通知的过程
* 中断：收到消息后发出的通知
* 时钟是硬件，会向Windows发送中断，而Windows会用异步的方式处理这些消息
* 时钟并不精准，它依靠ROM BIOS的计时逻辑
	* Windows通过获取其产生的"时钟滴答"来计时(每54.925毫秒产生一次)，设定为一秒的计时器每989毫秒收到一个中断
	* 如果设定时间短语一个时钟滴答，程序会接收到每一个时钟滴答的中断
* 计时器不同于Windows，它处理时钟中断不是异步的
	* 它和其他平凡的消息一样，都是等在消息队列中被处理的
	* 如果程序进入某个消息中超过设定计时器的时间，那么窗口过程不会接收到任何`WM_TIMER`消息
* `WM_TIMER`和`WM_PAINT`很像
	* 都是低优先级的，只有在队列中没有其他消息时才会处理这两条消息
	* 队列中不会出现**连续多条**一样的消息，Windows会把它们合并
	* 程序永远不知道自己错过了多少条一样的消息，哈哈哈哈哈哈
####使用计时器的三种方法
1. 把`WM_TIMER`直接发送到WndProc进行处理
2. 利用回调函数，把计时器消息发送到指定函数中处理
* 回调函数：主函数调用的函数，运行完成后会返回到主函数
* 处理计时消息的函数必须是CALLBACK类型的
```c
VOID CALLBACK TimerProc(HWND hwnd, UINT message, DWORD dwTime)
{
	//处理消息
}
```
* `message`永远都是`WM_TIMER`没什么卵用
* `dwTime`记录了Windows从启动开始到现在为止经过的毫秒数
3. 把`SetTimer()`的第一个参数设置为NULL，导致第二个参数被忽略，这时不必在关心哪个计时器对应哪个ID，只要KILL就对了但是不能一次设置太多这种定时器，否则系统会一起杀掉有用的定时器

**数字时钟**

* `GetLocalTime(lpsystemTime)`用来获取当前电脑的时间
	* 想获取世界调和时(UTC)需要用`GetSystemTime()`
* 考虑国际化是个大麻烦需要用到`GetLocaleInfo()`具体我就先不看了。。。

**模拟时钟**

* 没啥好说的，注意不要用迭代法计算有误差的东西，不然误差越累积越大

**取色器 **

* `CreateIC()`更快的取得某一设备的设备环境句柄 ，但是GDI函数并不接受这种粗糙的句柄
* `GetPixel()`据作者所说，这个函数没啥用，也就拿来当取色器还有点用