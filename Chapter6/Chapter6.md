#键盘
* 键盘事件很多，明确不同事件的轻重缓急是关键
* Windows自己就会处理很多键盘事件
* 分送消息时接受键盘消息的窗口称为**有输入焦点的窗口**
	* 拥有焦点具体表现为有闪烁的光标
	* 只有**活动窗口**和**活动窗口的子窗口**可以有输入焦点
	* 窗口过程靠捕获`WM_SETFOCUS`和`WM_KILLFOCUS`来判断自己是否拥有输入焦点
* 用户的输入消息不会立刻被放入程序的消息队列，而是先放入**系统队列**，当前消息处理完之后再取出消息放入应该接受消息的程序的队列，如果把消息全部放入一个消息都队列，用户的某一个切换动作会使后续的消息全部失效（本来是给程序2的消息，全放在程序1那了）
* 键盘消息有两种**击键****字符**
	* 按下，松开都是击键，只要碰了键子就会产生这类消息
	* 能显示字符的键子会在产生击键消息时产生字符消息
####击键消息
* 键子分成两种，系统键和非系统键，消息也有两种按下，松开。所以击键消息一共有四种
	* `WM_KEYUP` `WM_KEYDOWN`
	* `WM_SYSKEYUP` `WM_SYSKEYDOWN`
	* `wParam`包含虚拟键代码，`lParam`包含本次击键的其他数据
* 大多数系统键都是*Alt组合键*，交给`DefWindowProc()`去处理就好了，但是也可捕获系统击键消息干点什么
**虚拟键代码**
* 原来的真实键盘码与键盘的相关性很强，但是虚拟键盘码则是无视物理设备的存在，一套在手天下我有
* 大部分的键盘码由`VK_`开头
* 主键盘上的数字键和字母键用**ASCII**代替了虚拟键盘码
* 小键盘有自己的标识符，和主键盘上的数字键不一样
**lParam**
* 不同于`wParam`，它包含的信息稍微复杂一点，32位的存储空间被切割成几段存储不同的东西
* 00~15-重复计数，用来表示击键的数目
	* 基本上都被设置为1
	* 如果按住一个键不放，而且程序太慢，那么Windows会合并多个`WM_KEYDOWN` `WM_SYSKEYDOEN`，并增加重复计数
	* `WM_KEYUP` `WM_SYSKEYUP`的重复计数总是1
*16~23-OEM扫描码，键盘硬件产生的代码
	* OEM=Original Equipment Manufacture
	* 需要处理*键盘上键的分布*时才会使用（网上介绍的很少，看来没啥用了）
* 24-扩展标记，用来处理有101或102个键的大键盘，当时用扩展键时，标记为1
* 29-内容代码，系统击键为1,两种情况例外（有1的不一定是系统击键，没1的未必是非系统击键）
	* 没有任何窗口具有输入焦点时任何击键将都属于系统击键，即使Alt没按下（内容代码为0）
	* 非美式英语键盘输入某些字符时需要用到组合键，内容代码可能为1，但并不是系统消息
* 30-键的先前状态
	* 之前是释放状态为0，按下状态为1
* 31-转换状态，正在被按下（DOWN系列）的键为0，正在被释放（UP系列）的键为1
**转换状态**
* 转义键：Shift Ctrl Alt；切换键：CapsLock NumLock ScrollLock
* `SHORT GetKeyState(nVirtKey)`用来获取相应键的状态
	* 按下-负值（最高位赋1）
	* 按下并锁住（CapsLock）最低位赋1
	* `nVirtKey`表示虚拟键代码
	* 表明了目前为止键盘的状态，并不会实时检查
**处理击键消息**
* Windows不会放过任何一条消息，但是它未必会处理
* 不要用击键消息和转义状态把击键消息转换为字符，因为你不知道用户用的是什么键盘
* `WM_KEYDOWN`最适合用来处理*光标移动键，功能键，Insert键，Delete键*
	* 后三种一般由Windows自己处理
	* 经常处理光标移动键，并辅以转义状态检查，有时会处理后三种键
* 处理键盘消息最好随大流，大家怎么做你怎么做
* `SendMessage(hwnd, message, wParam, lParam)`向指定窗口发送指定消息，并辅以相应的参数
	* 消息不处理完函数是不会返回的
####字符消息
* 击键消息预装一消息的组合可以产生字符消息，这一点程序员和Windows都清楚，所以才有了`TranslateMessage()`，它将组合消息转换成相应的字符消息并放入消息队列中的击键消息之后
* 字符消息有系统和非系统之分，也有普通和死之分，所以一共四种
	* `WM_CHAR` `WM_DEADCHAR`来自`WM_KEYDOWN`
	* `WM_SYSCHAR` `WM_DEADSYSCHAR`来自`WM_SYSKEYDOWN`
	* `lParam`的作用没变，`wParam`存储的是ANSI或者Unicode字符码 
	* `wParam`通过辨别`RegisterClass()`来确定自己存的是什么字符
* 处理输入字符、控制字符-`WM_CHAR`，处理控制键-`WM_KEYDOWN`
* **死键**自己不会产生字符，按下之后会产生一条`WM_DEADCHAR`并且`wParam`带有音调的消息

####键盘消息、字符集
* 键盘布局和字符集不一样
	* 键盘布局使得特定的击键组合得到不一样的键盘消息
	* 字符集则定义了键盘消息对应的字符，如果字符集不对即使用了正确的键盘布局也无法正常输入文字
	* 类似于进对房间上错床...
* Unicode版本的字符集最大的优势在于每一个字符编码没有二义性，不会因为不同的键盘布局而出现不同的字符

**TrueType字体，大字体**

* TrueType字体(FixedSys)是由填充区域定义字符的轮廓字体，TrueType使得显示器上的显示字体与输出字体精准匹配
* 位图字体(Terminal)是由显示器一组像素位值定义的，放大了看有锯齿，常用于Windows的标题栏，菜单什么的
	* 小字体文件名由VGA开头（IBM1987年推出的显卡640*480）
	* 大字体文件名由8514开头（IBM1987年推出的显卡1024*768）
* 与常用的位图字体不一样，TrueType字体包含的字符多余256个，TrueType字体有时也被称作**大字体**（大指多）
* `CreateFont()`用来创建字体，共有14个参数，第9个表示”字符集ID“
	* 不同语言的Windows使用不同字符ID
	* 不同于代码页ID，字符集ID的储存仅需1字节（省地方）
####插入符号
* 插入符号 ！= 光标（鼠标）
* Windows5个基本的插入符号函数

函数名 | 功能 
------- | ----
CreateCaret(hwnd, hBitmap, nWidth, nHeight) | 创建和窗口关联的插入符号
SetCaretPos（Ponit） | 设置插入符号的位置 
ShowCaret（） | 显示插入符号
HideCaret（） | 隐藏插入符号 
DestroyCaret（*pBitmap） | 销毁插入符号
GetCaretPos（cPoint） | 返回当前插入符号的位置

* `CreateCreat()`hBitmap是一个句柄（CreateBitMap）
	* 设置为NULL时是实心的
	* 设置为1时是灰色的
	* 是句柄时忽略后两个参数
	* 后两个参数由逻辑坐标指定了插入符号的大小
* 在窗口具有焦点时，窗口过程收到`WM_SETFOCUS`消息，失去焦点时收到`WM_KILLFOCUS`消息
	* 建议：接到`WM_SETFOCUS`消息时创建插入光标，接到`WM_KILLFOCUS`时销毁插入符号
* 创建出来的插入符号是隐藏的
* `HideCaret()` `ShowCaret()`拥有叠加效应 