#GDI结构
* 驱动程序类似于翻译，把GDI函数翻译成设备能理解的代码
* GDI就像是水，填平了设备与pc之间的沟壑，使得设备与pc连成平面，程序开发便能在平面进行，忽略设备间的差异
* GDI支持静态显示，对动画的支持能力有限

**GDI函数分类**
* 获取（创建）和释放（销毁）设备环境的函数
	* `BeginPaint()`-`EndPaint()`
	* `GetDC()`-`ReleaseDC()`
* 获取设备环境信息的函数
	* `GetTextMetrics()`获取选入设备环境的字体信息
* 绘图函数
	* `TextOut()`文本也算图像的一种
* 设置和获取设备环境属性的函数，用于确定绘图时的细节
	* `SetTextAlign()`
* 使用GDI对象的函数
	* 这些GDI对象的创建不需要设备环境句柄，就像封闭生态系统下发展出来的生物，虽然同样消耗自然资源，但自生自灭与外界无关

**GDI图像分类**
* 线条和曲线
* 可被填充的封闭区域
* 位图（点阵）
* 文本（由于其偏向艺术性的特质，使其成为了最复杂的图像）

#设备环境

**获取句柄的方法**
	* `Beginpaint()` `EndPaint()`
	* `GetDC()` `ReleaseDC()`
	* `GetWindowDC()`获取整个窗口的设备环境句柄 `ReleaseDC()`
	* `CreateDC()` `DeleteDC()`用起来挺复杂的，暂且不表
		* `CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL)`可以用来获取整个屏幕的设备环境句柄
	* `CreateIC()`(Information Context) 获取设备环境信息，快速，但是对GDI绘图函数来说，他没什么卵用...只是单纯的获取信息
	* `CreateCompatibleDC()` `DeleteDC()`获取内存设备环境句柄，处理位图用的，现在还不会用
	* `CreateMetaFile()` `CloseMetaFile()`类似于操作文件一样的操作图元文件

**获取设备环境信息**
* `GetDeviceCaps()`获取设备环境信息
	* 如果`hdc`指向一个屏幕设备，那么返回结果将和`GetSystemMetrics()`一样的结果

**设备的尺寸**
* 打印机的分辨率和显示器的不一样
	* 打印机dpi（dot oer inch),表示每英寸的点数
	* 显示器水平和垂直方向的像素总数
* 在Windows编程一书中对分辨率作了如下规定
	1. 分辨率=每度量单位（通常是英寸）含有的像素数
	2. 像素规模/像素尺寸 = 设备在水平方向和垂直方向上像素总数（显示器的分辨率）
	3. 度量尺寸/度量规模 = 以度量尺寸（英寸、毫米什么的）表示的大小
	4. **分辨率 = 像素尺寸 / 度量尺寸**
* 正方形像素：水平分辨率=垂直分辨率
* 字体大小由点值（磅值1/72in.）表示 = `tmHight` - `tmInternalLeading`
* Windows系统字体不管是小字体还是大字体，统统被假设为10磅字号，12磅行间距
	* 区别在于假定的显示器的分辨率不一样，大字体的分辨率大一些，用到的像素数量就多一些，看起来就更大
**GetDeviceCaps与尺寸相关的标识符**

标识符 | 含义
------- | -----
HORZRES/VERTRES | 两个方向的像素规模
LOGPIXELSX/LOGPIXELSY | 两个方向的分辨率
HORZSIZE/VERTSIZE | 两个方向的度量尺寸（由上面两个计算来的）
ASPECTX/ASPECTY/ASPECTXY | 每个像素的物理尺寸（长、宽、对角线）

**尺寸（mm）=25.4 * 像素规模/分辨率**
* Windows不关心物理尺寸，想获得准确的尺寸最好让用户自己输入...

**色彩**
* 显示色彩越丰富，每个像素用于储存颜色信息的内存越大（黑白显示器只要1byte/pi）
* 显示器支持的色彩数 = 1<<(GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL))(2的n次方）
* 调用GDI函数时一般使用COLORREF（无符号长整形）表示一种特定颜色（RGB色彩，从右到左每8位表示一种颜色，按照红绿蓝排序，最后8位全是0）
* `RGB(r, g, b)`宏用来取得一个COLORREF色彩值
* `GetR/G/BValue`宏用来提取相应颜色的值
* 抖动：能让显示器显示更多色彩的方法，用不同色彩的相邻像素组成一种色彩的方法
	* `GetNearestColor(hdc, crColor)`用来获取与该颜色最接近的非合成色

**保存设备环境**
1. 在`wndclass.style`中加入`CS_OWNDC`,使得初始化一次之后的设备环境变量在使用`GetDC()`或者`BeginPaint()`之后还能继续使用（其他获取 方式不可以）
2. 使用`idSaved = SaveDC(hdc)`（返回之前的设备环境变量）和`RestoreDC(hdc, idSaved)`（重载之前的设备环境变量）

#点和线的绘制
**点**
* `SetPixel(hdc, x, y, crColor)`在点（x，y）处画一个颜色为`crColor`的点

**线**
Windows的画线函数

函数 | 功能
---- | -----
LineTo(hdc, x, y) | 从当前位置画一条线到（x，y）
Polyline(hdc, lpPoints, nCounts) | 连接`lpPoints`指定的点，连成一条线（和当前位置无关）
PolylineTo(hdc, lpPoints, nCounts) | 从当前位置开始，其它同上
PolyPolyline(hdc, lpPoints, lpPolyPoints, nCount) | 一次画多个折线,`lpPolyPoints`表示每个折线包含的点数
Arc(x1,y1,x2,y2,x3,y3,x4,y4) | 前两个点确定椭圆范围，后两个点确定画线的起始位置
Arc(lpRect, ptStart, ptEnd) | 作用和上面一样
ArcTo(参数和上面两个相同) | 作用一样，但是会更新当前点的位置
PolyBezier(lpPoints, nCounts) | 用来画贝塞尔样条曲线
PolyBezierTo(lpPoints, nCounts) | 作用同上 
PolyDraw(lpPoints, lpTypes, nCount) | 画多条贝塞尔样条曲线，或者多条折线

* 对绘制线条有影响的5个设备环境中的属性
	* 当前位置（仅对带To的函数有影响 ）
	* 画笔
	* 背景模式
	* 背景颜色
	* 绘制模式
* `MoveToEX(hdc, x, y, lpPoint)`改变当前位置，并且lpPoint将接收到之前位置的坐标，所有坐标都是32位的
	* `GetCurrentPositionEX(hdc, lpPoint)`取得当前位置

**面**

函数 | 功能
----- | ----
Rectangle(hdc, x1, y1, x2, y2) | 画一个矩形
Ellipse(hdc, x1, y1, x2, y2) | 画一个椭圆
RoundRect(x1, y1, x2, y2, x3, y3) | 乔布斯最爱的圆角矩形，第三对不是坐标，表示圆角椭圆的长宽
RoundRect(lpRect, POINT) | POINT就是上面的第三对参数，他们不是坐标！！！
Pie(x1, y1, x2, y2, x3, y3, x4, y4) | 画椭圆的一部分，并与中心连接看起来像扇形
Pie(lpRect, ptStart, ptEnd) | 同上
Chord(参数和上面两个一样) | 画出由弦割出的部分椭圆

* 边界偏差：绘制函数给出的两点限制的边框内画矩形框
* 对于`Pie` `Chord`  `Arc`指定的起始点不需要在矩形框里指定，Windows将绘制两点连线与椭圆相交两点间的图像